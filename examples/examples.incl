EXAMPLE_X(reverse_standard, 0, "Reverse standard", {
    // This examples reverses a list
    // not in place though, by using another list
    // memory wise the same.
    // new_LL pushes it to a global LL for update to work on.
    LL to_reverse = ll_new("Original List");
    for (int i = 0; i < 10; i++) {
        // while you could do ll_new_node((Data){i}, INTEGER)
        // you can also just use this great macro, which is honestly beautiful
        ll_insert_after(to_reverse, NEW_NODE(ll, (double)i * 10000000.0), to_reverse->tail);
    }

    LL reversed = ll_new("Reversed");
    // i've included the longer way as well for your 'enjoyment'
    LL_Node cur = to_reverse->head;
    // SET_PTR(cur, "cur");
    attach_ptr(&cur, "cur");

    fmt_update("%l %l", to_reverse, reversed);

    // tons of helper functions such as remove_node, insert_node and so on
    while (cur != NULL) {
        // UNSET_PTR(cur);
        ll_push(reversed, ll_new_node(cur->data, cur->data_tag));
        // a simpler update looks like;
        // `update(2, to_reverse, reversed);`
        // a more complex one is like
        cur = cur->next;
        // SET_PTR(cur, "cur");
        fmt_update("%l %l", to_reverse, reversed);
    }

    // if you care about freeing
    deattach_ptr(&to_reverse->head, "cur");
    ll_free(to_reverse);
    ll_free(reversed);
})

EXAMPLE_X(bubble_sort, 1, "Sort List", {
    int *values = ((int[]){1, 1000, 9, 90, 110, 54, 10});
    Array array = array_new("Sorting List", ARRAY_LEN(values));
    for (int i = 0; i < ARRAY_LEN(values); i++) {
        array_set(array, i, NEW_NODE(array, values[i]));
    }

    fmt_update("%l", array);

    ArrayNode n1 = NULL;
    ArrayNode n2 = NULL;
    attach_ptr(&n1, "a");
    attach_ptr(&n2, "b");

    bool changes = true;
    while (changes) {
        changes = false;
        for (int i = 0; i < ARRAY_LEN(values) - 1; i++) {
            n1 = array_at(array, i);
            n2 = array_at(array, i + 1);
            fmt_update("%l", array);

            // swap
            if (n1->data.int_data > n2->data.int_data) {
                struct _array_data_t tmp = *n1;
                array_set(array, i, *n2);
                array_set(array, i + 1, tmp);
                changes = true;

                n2 = n1;
                n1 = array_at(array, i + 1);
                fmt_update("%l %s", array, "b < a therefore swap");
            }
        }
    }

    deattach_ptr(&n1, "a");
    deattach_ptr(&n2, "b");
    fmt_update("%s %l", "All sorted", array);
    array_free(array);
})

EXAMPLE_X(dll_insert_user, 2, "DLL insert from user prompt", {
    DLL list = dll_new("Adding elements to list from user prompt");


    fmt_update("%l", list);
    int *values = ((int[]){100, 24, 345, 59, 393, 292, 12, 500, 800, 900, 40044040});
    for (int i = 0; i < ARRAY_LEN(values); i++) {
        dll_append(list, NEW_NODE(dll, values[i]));
        fmt_update("%l", list);
    }
    fmt_update("%l", list);
})
